<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>音声エフェクトメーカー</title>
    <style>
        body { font-family: Arial, sans-serif; }
        .controls { margin-top: 20px; }
        .effects { margin-top: 20px; }
        .section { margin-bottom: 20px; }
        button { margin-top: 10px; }
    </style>
</head>
<body>
    <h1>音声エフェクトメーカー</h1>

    <div id="waveform-section" class="section">
        <h2>波形の選択</h2>
        <select id="waveform-type">
            <option value="sine">サイン波</option>
            <option value="sawtooth">ノコギリ波</option>
            <option value="triangle">三角波</option>
            <option value="square">矩形波</option>
        </select>
    </div>

    <div id="effect-section" class="effects section">
        <h2>エフェクトの選択</h2>
        <select id="effect-type">
            <option value="windows7">Windows 7</option>
            <option value="soboro">そぼろ風</option>
            <option value="pulse">パルス風</option>
            <option value="windows11">Windows 11</option>
        </select>
        <button id="apply-effect">エフェクトを適用</button>
    </div>

    <div id="controls" class="controls section">
        <button id="play">再生</button>
        <button id="export">WAVとしてエクスポート</button>
    </div>

    <audio id="audio" controls></audio>

    <script>
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let buffer;

        function createWaveformBuffer(waveform, frequency, duration) {
            const sampleRate = audioContext.sampleRate;
            const length = sampleRate * duration;
            const audioBuffer = audioContext.createBuffer(1, length, sampleRate);
            const data = audioBuffer.getChannelData(0);

            for (let i = 0; i < length; i++) {
                const t = i / sampleRate;
                switch (waveform) {
                    case 'sine':
                        data[i] = Math.sin(2 * Math.PI * frequency * t);
                        break;
                    case 'sawtooth':
                        data[i] = (2 * (t * frequency - Math.floor(t * frequency + 0.5))) - 1;
                        break;
                    case 'triangle':
                        data[i] = 1 - (4 * Math.abs(Math.round(t * frequency) - (t * frequency + 0.5)));
                        break;
                    case 'square':
                        data[i] = Math.sign(Math.sin(2 * Math.PI * frequency * t));
                        break;
                }
            }
            return audioBuffer;
        }

        function applyEffect(effectType, audioBuffer) {
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            const gainNode = audioContext.createGain();
            const biquadFilter = audioContext.createBiquadFilter();
            const convolver = audioContext.createConvolver();
            let effectBuffer;

            switch (effectType) {
                case 'windows7':
                    // Apply Windows 7 effect
                    effectBuffer = createWaveformBuffer('sine', 440, 1);
                    biquadFilter.type = 'lowpass';
                    biquadFilter.frequency.setValueAtTime(2000, audioContext.currentTime);
                    break;
                case 'soboro':
                    // Apply Soboro effect
                    effectBuffer = createWaveformBuffer('sine', 440, 1);
                    biquadFilter.type = 'highpass';
                    biquadFilter.frequency.setValueAtTime(1000, audioContext.currentTime);
                    break;
                case 'pulse':
                    // Apply Pulse effect
                    effectBuffer = createWaveformBuffer('sine', 440, 1);
                    biquadFilter.type = 'bandpass';
                    biquadFilter.frequency.setValueAtTime(1000, audioContext.currentTime);
                    break;
                case 'windows11':
                    // Apply Windows 11 effect
                    effectBuffer = createWaveformBuffer('sine', 440, 1);
                    biquadFilter.type = 'peaking';
                    biquadFilter.frequency.setValueAtTime(5000, audioContext.currentTime);
                    biquadFilter.gain.setValueAtTime(10, audioContext.currentTime);
                    break;
                default:
                    effectBuffer = audioBuffer;
            }

            convolver.buffer = effectBuffer;
            source.connect(biquadFilter);
            biquadFilter.connect(convolver);
            convolver.connect(audioContext.destination);
            return convolver;
        }

        document.getElementById('apply-effect').addEventListener('click', () => {
            const effectType = document.getElementById('effect-type').value;
            const waveformType = document.getElementById('waveform-type').value;
            const frequency = 440; // Example frequency
            const duration = 2; // Example duration
            const originalBuffer = createWaveformBuffer(waveformType, frequency, duration);

            const effect = applyEffect(effectType, originalBuffer);
            effect.start();
        });

        document.getElementById('play').addEventListener('click', () => {
            const effectType = document.getElementById('effect-type').value;
            const waveformType = document.getElementById('waveform-type').value;
            const frequency = 440; // Example frequency
            const duration = 2; // Example duration
            const audioBuffer = createWaveformBuffer(waveformType, frequency, duration);
            const effect = applyEffect(effectType, audioBuffer);
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(effect);
            source.start();
        });

        document.getElementById('export').addEventListener('click', () => {
            const effectType = document.getElementById('effect-type').value;
            const waveformType = document.getElementById('waveform-type').value;
            const frequency = 440; // Example frequency
            const duration = 2; // Example duration
            const audioBuffer = createWaveformBuffer(waveformType, frequency, duration);
            const effect = applyEffect(effectType, audioBuffer);
            effect.connect(audioContext.destination);

            const wav = audioBufferToWav(audioBuffer);
            const blob = new Blob([wav], { type: 'audio/wav' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'effect.wav';
            a.click();
            URL.revokeObjectURL(url);
        });

        function audioBufferToWav(audioBuffer) {
            const numChannels = audioBuffer.numberOfChannels;
            const sampleRate = audioBuffer.sampleRate;
            const length = audioBuffer.length * numChannels * 2 + 44;
            const buffer = new ArrayBuffer(length);
            const view = new DataView(buffer);

            writeString(view, 0, 'RIFF');
            view.setUint32(4, length - 8, true);
            writeString(view, 8, 'WAVE');

            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * 2, true);
            view.setUint16(32, numChannels * 2, true);
            view.setUint16(34, 16, true);

            writeString(view, 36, 'data');
            view.setUint32(40, audioBuffer.length * numChannels * 2, true);

            const channelData = new Float32Array(audioBuffer.length * numChannels);
            for (let i = 0; i < numChannels; i++) {
                const data = audioBuffer.getChannelData(i);
                for (let j = 0; j < data.length; j++) {
                    channelData[j * numChannels + i] = data[j];
                }
            }

            let offset = 44;
            for (let i = 0; i < channelData.length; i++) {
                view.setInt16(offset, channelData[i] * 0x7FFF, true);
                offset += 2;
            }

            return buffer;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
    </script>
</body>
</html>
